<!DOCTYPE html>
<html lang="cs" dir="ltr">
	<head>
		<meta charset="UTF-8">
		<title>Examples</title>
		<link href="/assets/css/base.css" type="text/css" rel="stylesheet" />
		<link href="/assets/css/highlighter.css" type="text/css" rel="stylesheet" />
		
			<link href="/assets/css/detail.css" type="text/css" rel="stylesheet" />
		
	</head>
	<body data-spy="scroll" data-target="#panel">
		
	

	

		<!--- Hlavní menu (automaticky generované na základě /_config.yml) -->
		<nav>
	<a class="logo" href="/" title="Opensource projects"><span>Opensource projects</span></a> 
	<ul class="menu">
		
			
				<li><a title="About" href="/shallocator/index.html">About</a></li>			
			
		
			
				<li><a title="Examples" href="/shallocator/documentation/examples.html" class="active">Examples</a></li>
			
		
			
				<li><a title="Find me at GitHub" href="https://github.com/seznam/shallocator">Find me at GitHub</a></li>			
			
		
	</ul>
	<ul class="right">
		<li><a target="_blank" href="http://www.seznam.cz">Seznam.cz</a></li>
	</ul>
</nav>
		<div id="content">

			<!--- Levý panel (automaticky generované na základě /_config.yml) -->
			<aside id="panel">
	<div id="visible-panel">
		<ul class="nav">
			
				<li class="item first-visiblelast"><a href="#example">Two processes sharing a set</a></li>
			
		</ul>
	</div>
	<div id="arrows" class="last">
		<div class="arrow prev"></div>
		<div class="arrow next active"></div>
	</div>				
</aside>

			<!--- Obsah: /nazev-projektu/dokumentace/index.html -->
			<article>
				<section id="example">
    <h1>Example</h1>
    <p class="description">Two communicating processes</p>
    <p>The example here shows two communicating processes that share a std::set. The first process fills the std::set and after it ends, the second iterates it through and lists imposed values to std::cout. Communication is synchronized using the standard mutex created via SYSV semaphores.</p>
<div class="highlight"><pre><code class="cpp"><span class="cp">#include &lt;mm.h&gt;;</span>
<span class="cp">#include &lt;cerrno&gt;;</span>
<span class="cp">#include &lt;cstdlib&gt;</span>
<span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;sys/ipc.h&gt;</span>
<span class="cp">#include &lt;sys/sem.h&gt;</span>
<span class="cp">#include &lt;sys/types.h&gt;</span>
<span class="cp">#include &lt;shallocator/shset.h&gt;</span>
<span class="cp">#include &lt;shallocator/shmemory.h&gt;</span>
<span class="cp">#include &lt;shallocator/shstring.h&gt;</span>

<span class="cp">#ifdef _SEM_SEMUN_UNDEFINED  </span><span class="c1">// see sys/sem.h</span>

<span class="k">union</span> <span class="n">semun</span> <span class="p">{</span>
    <span class="kt">int</span>              <span class="n">val</span><span class="p">;</span>    <span class="c1">// value for SETVAL</span>
    <span class="k">struct</span> <span class="n">semid_ds</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>    <span class="c1">// buffer for IPC_STAT, IPC_SET</span>
    <span class="kt">unsigned</span> <span class="kt">short</span>  <span class="o">*</span><span class="n">array</span><span class="p">;</span>  <span class="c1">// array for GETALL, SETALL</span>
    <span class="k">struct</span> <span class="n">seminfo</span>  <span class="o">*</span><span class="n">__buf</span><span class="p">;</span>  <span class="c1">// buffer for IPC_INFO (Linux-specific)</span>
<span class="p">};</span>

<span class="cp">#endif </span><span class="c1">// _SEM_SEMUN_UNDEFINED</span>

<span class="cm">/** </span>
<span class="cm"> * @short Holder for sem set id.</span>
<span class="cm"> */</span>
<span class="k">class</span> <span class="nc">SemSetIdHolder_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">SemSetIdHolder_t</span><span class="p">(</span><span class="kt">int</span> <span class="n">semsetid</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">semsetid</span><span class="p">(</span><span class="n">semsetid</span><span class="p">),</span> <span class="n">hold</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// check semaphore set id</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">semsetid</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;semget: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
            <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/** </span>
<span class="cm">     * @short Deallocate semaphore set.</span>
<span class="cm">     */</span>
    <span class="o">~</span><span class="n">SemSetIdHolder_t</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">hold</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">semctl</span><span class="p">(</span><span class="n">semsetid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">IPC_RMID</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;semctl: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
                <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">operator</span> <span class="kt">int</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">semsetid</span><span class="p">;}</span>

    <span class="kt">void</span> <span class="n">release</span><span class="p">()</span> <span class="p">{</span> <span class="n">hold</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;}</span>

<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">semsetid</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">hold</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/** </span>
<span class="cm"> * @short IPC semaphore mutex.</span>
<span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Mutex_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="cm">/** </span>
<span class="cm">     * @short Allocate new semaphore set.</span>
<span class="cm">     */</span>
    <span class="n">Mutex_t</span><span class="p">()</span>
        <span class="o">:</span> <span class="n">semsetid</span><span class="p">(</span><span class="n">semget</span><span class="p">(</span><span class="n">IPC_PRIVATE</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">IPC_CREAT</span> <span class="o">|</span> <span class="mo">0600</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="c1">// init semaphore</span>
        <span class="k">union</span> <span class="n">semun</span> <span class="n">arg</span><span class="p">;</span>
        <span class="n">arg</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">semctl</span><span class="p">(</span><span class="n">semsetid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SETVAL</span><span class="p">,</span> <span class="n">arg</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;semctl: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
            <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">lock</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// prepare structure for lock</span>
        <span class="k">struct</span> <span class="n">sembuf</span> <span class="n">op</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">SEM_UNDO</span><span class="p">};</span>

        <span class="c1">// lock</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">TEMP_FAILURE_RETRY</span><span class="p">(</span><span class="n">semop</span><span class="p">(</span><span class="n">semsetid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;semop: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
            <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">unlock</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// prepare structure for unlock</span>
        <span class="k">struct</span> <span class="n">sembuf</span> <span class="n">op</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">SEM_UNDO</span><span class="p">};</span>

        <span class="c1">// unlock</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">TEMP_FAILURE_RETRY</span><span class="p">(</span><span class="n">semop</span><span class="p">(</span><span class="n">semsetid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;semop: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
            <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">release</span><span class="p">()</span> <span class="p">{</span> <span class="n">semsetid</span><span class="p">.</span><span class="n">release</span><span class="p">();}</span>

<span class="nl">private:</span>
    <span class="n">Mutex_t</span><span class="p">(</span><span class="k">const</span> <span class="n">Mutex_t</span> <span class="o">&amp;</span><span class="p">);</span>
    <span class="n">Mutex_t</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Mutex_t</span> <span class="o">&amp;</span><span class="p">);</span>

    <span class="n">SemSetIdHolder_t</span> <span class="n">semsetid</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/** </span>
<span class="cm"> * @short Scope locker.</span>
<span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Lock_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Lock_t</span><span class="p">(</span><span class="n">Mutex_t</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">)</span><span class="o">:</span> <span class="n">mutex</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span> <span class="p">{</span> <span class="n">mutex</span><span class="p">.</span><span class="n">lock</span><span class="p">();}</span>
    <span class="o">~</span><span class="n">Lock_t</span><span class="p">()</span> <span class="p">{</span> <span class="n">mutex</span><span class="p">.</span><span class="n">unlock</span><span class="p">();}</span>

<span class="nl">private:</span>
    <span class="n">Lock_t</span><span class="p">(</span><span class="k">const</span> <span class="n">Lock_t</span> <span class="o">&amp;</span><span class="p">);</span>
    <span class="n">Lock_t</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Lock_t</span> <span class="o">&amp;</span><span class="p">);</span>
    <span class="n">Mutex_t</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/** </span>
<span class="cm"> * @short Shared memmory pool holder.</span>
<span class="cm"> */</span>
<span class="k">class</span> <span class="nc">SHPool_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">SHPool_t</span><span class="p">()</span><span class="o">:</span> <span class="n">hold</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span> <span class="n">MM_create</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">0</span><span class="p">);}</span>
    <span class="o">~</span><span class="n">SHPool_t</span><span class="p">()</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="n">hold</span><span class="p">)</span> <span class="n">MM_destroy</span><span class="p">();}</span>
    <span class="kt">void</span> <span class="n">release</span><span class="p">()</span> <span class="p">{</span> <span class="n">hold</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;}</span>

<span class="nl">private:</span>
    <span class="n">SHPool_t</span><span class="p">(</span><span class="k">const</span> <span class="n">SHPool_t</span> <span class="o">&amp;</span><span class="p">);</span>
    <span class="n">SHPool_t</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">SHPool_t</span> <span class="o">&amp;</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">hold</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/** </span>
<span class="cm"> * @short Usage example.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">process</span><span class="p">(</span><span class="n">SHAllocator</span><span class="o">::</span><span class="n">shauto_ptr</span>
             <span class="o">&lt;</span><span class="n">SHAllocator</span><span class="o">::</span><span class="n">shset</span><span class="o">&lt;</span><span class="n">SHAllocator</span><span class="o">::</span><span class="n">shstring</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">set</span><span class="p">,</span>
             <span class="n">SHPool_t</span> <span class="o">&amp;</span><span class="n">pool</span><span class="p">,</span> <span class="n">Mutex_t</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// if I&#39;m first the set is empty</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="c1">// prepare some value</span>
        <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
        <span class="n">snprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>

        <span class="c1">// store value in set</span>
        <span class="n">set</span><span class="o">-&gt;</span><span class="n">insert</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>

        <span class="c1">// I shouldn&#39;t destroy set since other process is going to work with it</span>
        <span class="n">set</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
        <span class="n">pool</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
        <span class="n">mutex</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>

    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// dump data to std::cout</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">SHAllocator</span><span class="o">::</span><span class="n">shset</span><span class="o">&lt;</span><span class="n">SHAllocator</span><span class="o">::</span><span class="n">shstring</span><span class="o">&gt;::</span><span class="n">const_iterator</span>
                <span class="n">iset</span> <span class="o">=</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">(),</span> <span class="n">eset</span> <span class="o">=</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">();</span>
                <span class="n">iset</span> <span class="o">!=</span> <span class="n">eset</span><span class="p">;</span> <span class="o">++</span><span class="n">iset</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">getpid</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;: &quot;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">iset</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/** </span>
<span class="cm"> * @short The main.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="cm">/*argc*/</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span> <span class="cm">/*argv*/</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// allocate space for new allocator</span>
    <span class="n">SHPool_t</span> <span class="n">pool</span><span class="p">;</span>

    <span class="c1">// get new mutex</span>
    <span class="n">Mutex_t</span> <span class="n">mutex</span><span class="p">;</span>

    <span class="c1">// create new set container and store new pointer into auto_ptr</span>
    <span class="n">SHAllocator</span><span class="o">::</span><span class="n">shauto_ptr</span><span class="o">&lt;</span><span class="n">SHAllocator</span><span class="o">::</span><span class="n">shset</span><span class="o">&lt;</span><span class="n">SHAllocator</span><span class="o">::</span><span class="n">shstring</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">set</span>
       <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">SHAllocator</span><span class="o">::</span><span class="n">SHAlloc</span><span class="p">)</span> <span class="n">SHAllocator</span><span class="o">::</span><span class="n">shset</span><span class="o">&lt;</span><span class="n">SHAllocator</span><span class="o">::</span><span class="n">shstring</span><span class="o">&gt;</span><span class="p">());</span>

    <span class="c1">// do fork - don&#39;t care about errors ;-)</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fork</span><span class="p">())</span> <span class="p">{</span>
        <span class="c1">// in child lock mutex first</span>
        <span class="n">Lock_t</span> <span class="n">lock</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>

        <span class="c1">// try insert if child lock mutex first or dump data and destroy</span>
        <span class="c1">// all resources</span>
        <span class="n">process</span><span class="p">(</span><span class="n">set</span><span class="p">,</span> <span class="n">pool</span><span class="p">,</span> <span class="n">mutex</span><span class="p">);</span>

    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// in parent lock mutex first too</span>
        <span class="n">Lock_t</span> <span class="n">lock</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>

        <span class="c1">// try insert if parent lock mutex first or dump data and destroy</span>
        <span class="c1">// all resources</span>
        <span class="n">process</span><span class="p">(</span><span class="n">set</span><span class="p">,</span> <span class="n">pool</span><span class="p">,</span> <span class="n">mutex</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
</section>

			</article>

		</div>

	

	

	

	

	


		<div class="cleaner"></div>
<footer>
	<div class="centered">
		<a class="link" href="http://onas.seznam.cz/en">About Seznam</a>
		<a class="link" href="http://vyvojari.seznam.cz/">Seznam Developers (Czech only)</a>
		<a class="link" href="http://twitter.com/seznamvyvojari">@SeznamVyvojari (Czech only)</a>
	</div>
</footer>

		<script src="/assets/js/jquery/jquery-2.0.0.min.js"></script>
		<script src="/assets/js/jquery/jquery-migrate-1.2.0.min.js"></script>
		<script src="/assets/js/bootstrap/bootstrap.affix.js"></script>
		<script src="/assets/js/bootstrap/bootstrap.scrollspy.js"></script>
		<script src="/assets/js/bootstrap/bootstrap.scroller.js"></script>
		<script src="/assets/js/application.js"></script>
		<!--[if IE]>
			<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
		<![endif]-->
	</body>
</html>